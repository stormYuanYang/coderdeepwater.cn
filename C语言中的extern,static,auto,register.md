今晚继续在阅读**Skynet**的源代码。Skynet的源代码出现了多处**static**关键词和**extern**关键词。突然发现自己对static和extern的概念和作用的记忆有些模糊了。索性花点时间重温static、extern以及和其作用类似的auto、register。接下来，将对extern、static、auto、register的概念和作用做一个总结，但在此之前先说明几个概念。

什么是**翻译单元**？翻译单元一般可认为就是编译单元，而编译单元可以粗略地认为就是C编译器预处理之后的单个源文件。

变量按**作用域**划分:

+ **全局变量**
+ **局部变量**

一个全局变量意味着，它必须声明在函数之外，它可以被所有其他函数访问。但是当static修饰全局变量时，此时全局变量只能被当前**翻译单元**内的所有函数访问)。

一个局部变量意味着，它必须声明在函数内或者语句块中，它只能在声明的函数或者语句块中被访问。

变量按**生命周期**划分：

+ 程序执行期间存活的变量
+ 函数执行期间存活的变量
+ 语句块执行期间存活变量

函数按**作用域**划分：

+ 外部函数(声明函数的默认策略，程序内都可以访问)
+ 内部函数(一个翻译单元内能访问)

因为标准C并不支持内嵌函数，所以一般不考虑函数的生命周期。只要程序仍然在执行，函数就活着。

extern、static、auto、register是C语言用来表示函数或者变量的存储策略的4个关键词。它们也有更多的作用，如下表：

|   存储策略   |       生命周期       |                            作用域                            |
| :----------: | :------------------: | :----------------------------------------------------------: |
|  **extern**  |     程序执行期间     |                          整个程序内                          |
|  **static**  |     程序执行期间     | 函数：翻译单元内<br />全局变量：翻译单元内<br />局部变量：函数或者语句块中 |
|   **auto**   | 函数或语句块执行期间 |               只能修饰变量。函数或者语句块中。               |
| **register** | 函数或语句块执行期间 |               只能修饰变量。函数或者语句块中。               |

接下来我们对其一一说明。

先说**register**关键词。这个关键词，几乎都被快被我们遗忘了，甚至C++在过去的一段时间里都废弃过这个关键词，直到C++17才重新启用这个关键词。一般而言，我们很少会使用到该关键词。在变量声明时修饰变量暗示C编译器将此变量存储在寄存器或者其他快速的地方，而不是放入内存中。但是，C编译器不一定会将你用register修饰的变量存储在寄存器中，而是直接放在内存中，这是C编译器的自由。前文说了，register关键词只是暗示C编译器，到底怎么做仍然是C编译器的自由。当你使用register修饰一个变量的时候，这个变量的地址是无法被访问的，这是C编译器对变量的一种保护，你可以这样理解：存储在寄存器中的变量都不存在于内存中，怎么会有地址呢？如下代码：

```c
#include <stdio.h>
int main() {
    register int a = 1;
    printf("%p\n", &a);
    return 0;
}
```

运行上述代码，一般会出现类似“error| address of register variable ‘a’ requested”这样的报错信息。