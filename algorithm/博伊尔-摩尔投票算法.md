# 简介

博伊尔-摩尔投票算法原称“**Boyer-Moore majority vote algorithm**”，很多同学将其称呼为**摩尔投票算法**，这是不对和不公平的，我们应对计算机前辈有起码的尊重，不要忘记此算法的另一位发明者:**Boyer**。

**博伊尔-摩尔投票算法**在下文中简称**投票算法**，请知悉。**投票算法**由[Robert S. Boyer](https://en.wikipedia.org/wiki/Robert_S._Boyer)和[J Strother Moore](https://en.wikipedia.org/wiki/J_Strother_Moore)于1981年发明。

# 描述

**投票算法**目的是在**线性时间**复杂度和**常量**空间复杂度内找到**序列**中的**majority element**。什么是**majority element**？我将其翻译为**主要元素**，简称**主元**，注意不要混淆数学上的**主元**含义（数学上有个术语**众数**，其概念和此类似）。本文中的**主元**指，在**序列**中出现次数超过一半的**元素**。

如果我们需要找到**序列**中出现次数超过一半的**元素**(此时也是出现次数**最多**的元素)，也就是**主元**，就可以采用**投票算法**。

**投票算法**能在序列中找到**主元**的前提是序列中存在**主元**。不论序列中是否存在**主元**，**投票算法**都会找到一个元素：

+ 如果序列中存在**主元**，则此元素就是**主元**；
+ 否则，此元素不是**主元**。

那不知道序列中是否存在**主元**时，如何判断**投票算法**找到的元素是否是主元呢？很简单，只需要对序列再次遍历，计算**投票算法**找到的元素出现的次数：

+ 如果次数大于序列中元素数量的一半，此元素就是**主元**；
+ 否则，不是。

# 分析

**投票算法**的原理是比较简单的。用一个例子来说明投票算法的原理：

小明所在班级要选出一位班长；小明的班主任邓老师因为小明平时热爱学习和思考，为人大方、团结同学就推荐小明做这个班长；邓老师为了公平，要求全班同学投票，可以投赞成票、反对票、弃权票（投票选项写在卡片上），如果投票数超过全班人数的一半，则小明就被任命为班长；否则，小明就不能被任命为班长。现在，投票活动已经结束，所有的投票卡片已经收集完毕，现在邓老师决定让班级中成绩最好的小杨来统计投票结果。

小杨支着下巴，陷入了沉思：我如何找到投票数超过一半的选项呢？投赞成票的是赞成派，投反对票的是反对派，投弃权票的是弃权派；对于每一派来说，只关心投票的人是不是自己这一派，到底是其他哪一派并不关心。那我是不是可以这样统计：

1. 建立一个**计数器**初始化为0，并遍历所有的投票卡片；
2. 选取一张未统计的卡片，如果计数器当前为0，则计数器加1，并记录下当前卡片对应的选项；否则，计数器一定是大于0的，说明计数器已经记录了某一选项的投票数，如果当前卡片的选项和计数器代表的选项是一样的，则计数器加1，否则计数器减1。
3. 重复步骤2，直到所有投票卡片都已统计完毕；统计完毕后，我根据计数器的数量而记录下的卡片选项x就一定是投票数超过一半的选项；哦，不对，不一定是投票数超过一半的选项；我需要再次遍历所有的投票卡片，统计x的数量，就能知道x是不是大于投票数的一半了。

小杨直觉这样能找到，投票数超过一半的选项，但是不知道方法对不对，所以他去请教了邓老师，有了如下对话：

邓老师：“小杨啊，你这样想是正确的，而且你和计算机前辈的想法不谋而合。”

小杨：“啥？我这么厉害。”

邓老师：“哈哈。是的，你这个想法早就有人提出来了，叫做**博伊尔-摩尔投票算法**。这个算法的目的就是找到在投票中出现超过一半的选项啦。”

小杨：“但是，邓老师，如何证明这个算法的正确性呢？”

“咳咳”，邓老师咳了一下，抿了一口浓茶，慢慢说道：“咱们先假设投票选项中有超过一半人数的选项，我们将此称为**主元**；对于主元来说，非主元的数量一定是小于主元的；你建立一个计数器，并记录下当前计数器对应的卡片选项，如果接下来的卡片选项是不同的就更新计数器（计数器为0时）对应的选项或者计数器直接减1（计数器大于0时）；这样在遍历卡片的过程中，不同的投票选项相互抵消，最后剩下的数量大于0的选项就一定是**主元**啦，你说是不是。”

小杨沉思片刻后说：“哦！原来是这样。对于选项来说，它只关心下一个选项是不是和自己相同，相同的话，计数器就加1；不同的话，就相互抵消了。这样最后剩下的肯定是**主元**，但这是建立在有**主元**的前提下，所以的到的结果不一定是正确的，我们可以再遍历一次卡片选项，看看得到的选项的数量是否超过了总数的一半。”

邓老师：“是的，你说的没错。如果我们不能确保有**主元**的话，就需要验证。”

小杨又想了想，说道：“邓老师，**投票算法**优势应该是在有很多种不同意见时，只通过遍历一次所有的意见就能知道超过一半的意见，并且通过再次遍历就可以验证。”

邓老师露出了满意的笑容：“对的，**投票算法**的优势就在于此。学习算法就是要多思考，你做得很不错。那你能告诉我**投票算法**的时间复杂度和空间复杂度吗？”

小杨：“没问题。**投票算法**，最多遍历两次序列，而且只会用到常量空间。所以**投票算法**的时间复杂度是$O(n)$，空间复杂度是$O(1)$。”

邓老师很满意地笑道：“不错，不错，分析地完全正确。那我现在给你留个作业。用代码实现**投票算法**。”

第二天，小杨以lua代码完成了作业，并将作业交给了邓老师，作业被邓老师分享给全班同学参考。

让我们一起看看小杨的作业：

```lua
local t = {1,2,3,4,1,1,1,1}
local majority
local count = 0
for i = 1, #t do
    if count == 0 then
        majority = t[i]
        count = count + 1
    else
        if majority == t[i] then
            count = count + 1
        else
            count = count - 1
        end
    end
end
print(majority)
```

是不是非常简单呢？:-)

# 引用

维基百科：[**Boyer-Moore majority vote algorithm**](https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm)